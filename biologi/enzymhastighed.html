<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enzym Laboratorium: Synkroniseret Logik</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* --- DESIGN & LAYOUT --- */
        body { font-family: 'Segoe UI', Roboto, sans-serif; background: #eceff1; text-align: center; padding: 10px; color: #37474f; }
        .container { max-width: 1100px; margin: 0 auto; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        
        h2 { margin-top: 0; color: #0277bd; }

        /* KONTROLPANEL */
        .controls-top {
            display: flex; justify-content: center; gap: 20px; margin-bottom: 20px;
            background: #e1f5fe; padding: 15px; border-radius: 8px;
        }
        .toggle-btn {
            padding: 12px 30px; border: none; border-radius: 25px; cursor: pointer;
            font-weight: bold; font-size: 1rem; transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .btn-active { background-color: #0277bd; color: white; transform: scale(1.05); }
        .btn-inactive { background-color: #b3e5fc; color: #0277bd; }

        /* SIMULATION */
        .sim-wrapper { position: relative; width: 100%; max-width: 900px; margin: 0 auto; }
        
        canvas#simCanvas {
            display: block; width: 100%; height: 400px;
            background: linear-gradient(to bottom, #ffffff, #f9fbe7);
            border: 2px solid #cfd8dc; border-radius: 8px; cursor: crosshair;
        }

        /* SPEEDOMETER */
        .gauge-overlay {
            position: absolute; top: 15px; right: 15px;
            width: 150px; height: 100px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #b0bec5; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .gauge-value { font-size: 28px; font-weight: bold; color: #e65100; font-family: monospace; transition: color 0.2s; }
        .gauge-label { font-size: 10px; color: #546e7a; text-transform: uppercase; margin-top: 5px; }

        /* STATUS DISPLAY */
        .status-display {
            position: absolute; top: 15px; left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px; border-radius: 6px;
            border-left: 6px solid #4caf50;
            font-weight: bold; font-size: 15px; color: #37474f;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        /* LEGENDE */
        .legend-box {
            display: flex; justify-content: center; gap: 40px; margin-top: 15px;
            background: #fafafa; padding: 12px; border-radius: 8px; border: 1px solid #eee;
        }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 14px; font-weight: 500; }
        .dot { width: 16px; height: 16px; border-radius: 50%; display: inline-block; border: 1px solid rgba(0,0,0,0.1); }

        /* SLIDERS */
        .sliders-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 25px; margin-top: 30px; text-align: left;
        }
        .slider-box { background: #f5f5f5; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; }
        .slider-box label { font-weight: bold; display: block; margin-bottom: 8px; font-size: 0.95em; color: #455a64; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #0277bd; height: 6px; }

        /* GRAFER */
        .charts-grid {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 30px;
        }
        .chart-box {
            background: white; border: 1px solid #ddd; border-radius: 8px; padding: 15px; 
            height: 280px; 
            display: flex; flex-direction: column;
        }
        h4 { margin: 0 0 10px 0; font-size: 15px; color: #546e7a; text-align: center; }
        .canvas-container { flex-grow: 1; position: relative; }

    </style>
</head>
<body>

<div class="container">
    <h2>Enzym Laboratorium: Synkroniseret Fysik & Logik</h2>

    <div class="controls-top">
        <button id="btn-breakdown" class="toggle-btn btn-active" onclick="setMode('breakdown')">Nedbrydning (Katabolsk)</button>
        <button id="btn-synthesis" class="toggle-btn btn-inactive" onclick="setMode('synthesis')">Opbygning (Anabolsk)</button>
    </div>

    <div class="sim-wrapper">
        <canvas id="simCanvas"></canvas>
        
        <div id="sim-status" class="status-display">Optimum - Reaktionen kører hurtigt</div>
        
        <div class="gauge-overlay">
            <canvas id="gaugeCanvas" width="120" height="60"></canvas>
            <div class="gauge-value" id="cpm-display">0</div>
            <div class="gauge-label">Reaktioner / min</div>
        </div>
    </div>

    <div class="legend-box" id="legend-container"></div>

    <div class="sliders-grid">
        <div class="slider-box">
            <label>Temperatur: <span id="val-temp">37</span>°C</label>
            <input type="range" id="slider-temp" min="0" max="70" value="37">
        </div>
        <div class="slider-box">
            <label>Enzym Koncentration [E]: <span id="val-enz">5</span></label>
            <input type="range" id="slider-enz" min="1" max="15" value="5">
        </div>
        <div class="slider-box">
            <label>Substrat Koncentration [S]: <span id="val-sub">30</span></label>
            <input type="range" id="slider-sub" min="5" max="100" value="30">
        </div>
    </div>

    <div class="charts-grid">
        <div class="chart-box">
            <h4>Aktivitet vs. Temperatur</h4>
            <div class="canvas-container"><canvas id="chartTemp"></canvas></div>
        </div>
        <div class="chart-box">
            <h4>Aktivitet vs. Enzym [E]</h4>
            <div class="canvas-container"><canvas id="chartEnz"></canvas></div>
        </div>
        <div class="chart-box">
            <h4>Aktivitet vs. Substrat [S]</h4>
            <div class="canvas-container"><canvas id="chartSub"></canvas></div>
        </div>
    </div>
</div>

<script>
    /** --- KONFIGURATION & STATE --- */
    const cvs = document.getElementById('simCanvas');
    const ctx = cvs.getContext('2d');
    cvs.width = 900; 
    cvs.height = 400;

    const state = {
        mode: 'breakdown', 
        temp: 37,
        enzymeCount: 5,
        substrateCount: 30,
        denatured: false,
        reactionsLastTick: 0 // Bruges til speedometer
    };

    // FYSIK PARAMETRE (Disse styrer både simulering og grafer)
    const PROCESSING_TIME_SEC = 1; // Tid det tager at omdanne
    const PROCESSING_FRAMES = 60; // Ved 60fps
    const MAX_THEORETICAL_RPM_PER_ENZYME = 60 / PROCESSING_TIME_SEC; // 120 RPM pr enzym

    let enzymes = [];
    let substrates = [];
    let products = [];

    const gaugeCtx = document.getElementById('gaugeCanvas').getContext('2d');
    
    // GLIDENDE GENNEMSNIT
    const HISTORY_SIZE = 50; 
    let reactionHistory = new Array(HISTORY_SIZE).fill(0);
    
    /** * --- MASTER CALCULATOR ---
     * Denne funktion sikrer at grafer og simulering altid er enige.
     * Den beregner den teoretiske hastighed baseret på Mætning.
     */
    function calculateTheoreticalRate(t, e, s) {
        // 1. Temperatur Faktor (0 til 1)
        let tempFactor = 0;
        if (t <= 40) {
            tempFactor = Math.pow(t / 40, 2); // Stiger til 1 ved 40
        } else {
            // Falder hurtigt efter 40 (denaturering)
            let diff = t - 40;
            tempFactor = Math.max(0, 1 - (Math.pow(diff, 2) / 100)); 
        }

        // 2. Maksimal Kapacitet (Vmax)
        // Hvor meget kan enzymerne klare, hvis de arbejder non-stop?
        let maxCapacity = e * MAX_THEORETICAL_RPM_PER_ENZYME * tempFactor;

        // 3. Substrat Tilgængelighed (Kollisionsrate)
        // Jo flere substrater, jo oftere mødes de.
        // Dette skal skaleres for at matche canvas-størrelse og fart.
        // Vi tuner '25' tallet så grafen passer med følelsen i spillet.
        let substrateAvailability = s * 25 * tempFactor; 

        // 4. Michaelis-Menten Logik (Harmonisk gennemsnit)
        // Rate = (Kapacitet * Tilgængelighed) / (Kapacitet + Tilgængelighed)
        // Dette skaber automatisk mætningskurven!
        if (maxCapacity === 0 || substrateAvailability === 0) return 0;
        
        let rate = (maxCapacity * substrateAvailability) / (maxCapacity + substrateAvailability);
        
        // Returner både rate og mætningsgrad (til graferne)
        return rate;
    }


    /** --- PARTIKEL KLASSER --- */
    class Particle {
        constructor(x, y, r) {
            this.x = x || Math.random() * cvs.width;
            this.y = y || Math.random() * cvs.height;
            this.r = r;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
        }
        move(speed) {
            if (speed <= 0) return;
            this.x += this.vx * speed;
            this.y += this.vy * speed;
            if(this.x < this.r || this.x > cvs.width - this.r) this.vx *= -1;
            if(this.y < this.r || this.y > cvs.height - this.r) this.vy *= -1;
            this.x = Math.max(this.r, Math.min(cvs.width - this.r, this.x));
            this.y = Math.max(this.r, Math.min(cvs.height - this.r, this.y));
        }
    }

    class Enzyme extends Particle {
        constructor() {
            super(null, null, 24);
            this.processing = 0;   
            this.holdingSubstrate = false;
        }
        
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            if (this.processing > 0) {
                let pulse = 1 + Math.sin(Date.now() / 50) * 0.1;
                ctx.scale(pulse, pulse);
            }

            if (state.denatured) {
                ctx.fillStyle = "#90A4AE";
                ctx.beginPath();
                ctx.moveTo(-15, -15); ctx.lineTo(10, -10); ctx.lineTo(5, 15); ctx.lineTo(-10, 10);
                ctx.fill();
            } else {
                ctx.fillStyle = (this.processing > 0) ? "#FBC02D" : "#43A047"; 
                let angle = Math.atan2(this.vy, this.vx);
                ctx.rotate(angle);
                ctx.beginPath();
                if (state.mode === 'breakdown') {
                    ctx.arc(0, 0, this.r, 0.2 * Math.PI, 1.8 * Math.PI);
                    ctx.lineTo(0,0);
                } else {
                    ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                }
                ctx.fill();
                
                if (state.mode === 'synthesis') {
                    ctx.fillStyle = (this.holdingSubstrate) ? "#1E88E5" : "#fff"; 
                    ctx.beginPath(); ctx.arc(-9, -6, 7, 0, Math.PI*2); ctx.fill(); 
                    ctx.fillStyle = (this.processing > 0) ? "#1E88E5" : "#fff"; 
                    ctx.beginPath(); ctx.arc(9, -6, 7, 0, Math.PI*2); ctx.fill(); 
                }
            }
            ctx.restore();
        }
    }

    class Substrate extends Particle {
        constructor() {
            super(null, null, 0);
            this.active = true; 
            if (state.mode === 'breakdown') {
                this.r = 14; this.color = "#FF6F00"; 
            } else {
                this.r = 8; this.color = "#1E88E5"; 
            }
        }
        draw() {
            if (!this.active) return;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
        }
    }

    class Product extends Particle {
        constructor(x, y) {
            super(x, y, 0);
            this.life = 60; 
            this.maxLife = 60;
            if (state.mode === 'breakdown') {
                this.r = 7; this.color = "#1E88E5"; 
            } else {
                this.r = 14; this.color = "#FF6F00"; 
            }
            this.vx = (Math.random()-0.5)*6;
            this.vy = (Math.random()-0.5)*6;
        }
        update() {
            this.life--;
            this.x += this.vx; this.y += this.vy;
        }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    /** --- SIMULATION LOOP --- */
    function initSim() {
        enzymes = []; substrates = []; products = [];
        for(let i=0; i<state.enzymeCount; i++) enzymes.push(new Enzyme());
        replenishSubstrates();
        reactionHistory.fill(0);
        updateLegend();
    }

    function replenishSubstrates() {
        while(substrates.length < state.substrateCount) {
            let s = new Substrate();
            if(Math.random()>0.5) s.x = (Math.random()>0.5)?0:cvs.width;
            else s.y = (Math.random()>0.5)?0:cvs.height;
            if(s.x === 0 || s.x === cvs.width) s.y = Math.random()*cvs.height;
            else s.x = Math.random()*cvs.width;
            substrates.push(s);
        }
        if(substrates.length > state.substrateCount) {
            substrates.splice(state.substrateCount);
        }
    }

    function updatePhysics() {
        let speedFactor = state.temp / 8;
        if(state.denatured) speedFactor = 1.5; 

        ctx.clearRect(0,0,cvs.width, cvs.height);

        enzymes.forEach(enz => {
            enz.move(speedFactor);
            if (enz.processing > 0) {
                enz.processing--;
                if (enz.processing === 0) {
                    state.reactionsLastTick++; 
                    if (state.mode === 'breakdown') {
                        products.push(new Product(enz.x, enz.y));
                        products.push(new Product(enz.x, enz.y));
                    } else {
                        products.push(new Product(enz.x, enz.y));
                        enz.holdingSubstrate = false; 
                    }
                }
            }
            enz.draw();
        });

        for (let i = substrates.length - 1; i >= 0; i--) {
            let sub = substrates[i];
            sub.move(speedFactor);
            sub.draw();

            if (!sub.active) { substrates.splice(i, 1); continue; }
            if (state.denatured) continue;

            enzymes.forEach(enz => {
                if (enz.processing > 0) return; 
                if (!sub.active) return;
                let dx = enz.x - sub.x;
                let dy = enz.y - sub.y;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < enz.r + sub.r) {
                    if (state.mode === 'breakdown') {
                        sub.active = false;
                        enz.processing = PROCESSING_FRAMES; 
                    } 
                    else { 
                        if (!enz.holdingSubstrate) {
                            enz.holdingSubstrate = true;
                            sub.active = false;
                            enz.processing = 10; 
                        } else {
                            sub.active = false;
                            enz.processing = PROCESSING_FRAMES; 
                        }
                    }
                }
            });
        }

        for (let i = products.length - 1; i >= 0; i--) {
            products[i].update();
            products[i].draw();
            if(products[i].life <= 0) products.splice(i, 1);
        }

        replenishSubstrates();
        requestAnimationFrame(updatePhysics);
    }

    // SPEEDOMETER (10Hz update)
    setInterval(() => {
        reactionHistory.shift();
        reactionHistory.push(state.reactionsLastTick);
        state.reactionsLastTick = 0;
        
        let sum = reactionHistory.reduce((a, b) => a + b, 0);
        let averageRPM = Math.round(sum * 12); 

        document.getElementById('cpm-display').innerText = averageRPM;
        drawGauge(averageRPM);

    }, 100);

    function drawGauge(val) {
        // Skala: Max RPM er teoretisk max for 15 enzymer (15 * 120 = 1800)
        let maxVal = 1800; 
        let percent = Math.min(val / maxVal, 1);
        
        let color = "#4caf50";
        if(val > 800) color = "#ffa000";
        if(val > 1400) color = "#e65100";
        document.getElementById('cpm-display').style.color = color;

        gaugeCtx.clearRect(0,0,120,60);
        gaugeCtx.beginPath();
        gaugeCtx.arc(60, 60, 50, Math.PI, 0);
        gaugeCtx.lineWidth = 12;
        gaugeCtx.strokeStyle = "#eceff1";
        gaugeCtx.stroke();
        gaugeCtx.beginPath();
        gaugeCtx.arc(60, 60, 50, Math.PI, Math.PI + (percent * Math.PI));
        gaugeCtx.strokeStyle = color;
        gaugeCtx.stroke();
    }

    /** --- GRAFER & LOGIK (NU DYNAMISKE) --- */
    function updateLegend() {
        const con = document.getElementById('legend-container');
        if(state.mode === 'breakdown') {
            con.innerHTML = `
                <div class="legend-item"><span class="dot" style="background:#43A047"></span> Enzym (Ledig)</div>
                <div class="legend-item"><span class="dot" style="background:#FBC02D"></span> Enzym (Arbejder)</div>
                <div class="legend-item"><span class="dot" style="background:#FF6F00"></span> Substrat</div>
                <div class="legend-item"><span class="dot" style="background:#1E88E5"></span> Produkt</div>
            `;
        } else {
            con.innerHTML = `
                <div class="legend-item"><span class="dot" style="background:#43A047"></span> Enzym (Ledig)</div>
                <div class="legend-item"><span class="dot" style="background:#FBC02D"></span> Enzym (Arbejder)</div>
                <div class="legend-item"><span class="dot" style="background:#1E88E5"></span> Substrat</div>
                <div class="legend-item"><span class="dot" style="background:#FF6F00"></span> Produkt</div>
            `;
        }
    }

    function updateStatus() {
        const el = document.getElementById('sim-status');
        const t = state.temp;
        let txt="", col="";
        state.denatured = false;

        if (t < 10) { txt = "Inaktiv (Koldt)"; col = "#90caf9"; }
        else if (t < 35) { txt = "Stigende Aktivitet"; col = "#fff176"; }
        else if (t >= 35 && t <= 45) { txt = "OPTIMUM"; col = "#a5d6a7"; }
        else if (t > 45 && t <= 55) { txt = "Begyndende Denaturering"; col = "#ffcc80"; }
        else { txt = "DENATURERET"; col = "#ef9a9a"; state.denatured = true; }

        el.innerText = `${t}°C - ${txt}`;
        el.style.backgroundColor = col;
        updateCharts();
    }

    function setMode(m) {
        state.mode = m;
        document.getElementById('btn-breakdown').className = m==='breakdown'?'toggle-btn btn-active':'toggle-btn btn-inactive';
        document.getElementById('btn-synthesis').className = m==='synthesis'?'toggle-btn btn-active':'toggle-btn btn-inactive';
        initSim();
    }

    /* --- CHART JS --- */
    let chartT, chartE, chartS;

    function initCharts() {
        const commonOpts = {
            responsive: true, maintainAspectRatio: false,
            plugins: { legend: {display: false}, tooltip: {enabled:false} },
            animation: { duration: 0 },
            scales: { 
                y: { min: 0, ticks: {display:false}, grid: {color: '#f0f0f0'}, title: {display:true, text: 'Reaktionshastighed'} }, 
                x: { grid: {display:false} } 
            }
        };

        chartT = new Chart(document.getElementById('chartTemp'), {
            type: 'line',
            data: {
                labels: Array.from({length:71}, (_,i)=>i),
                datasets: [
                    { data: [], borderColor: '#0277bd', borderWidth: 2, pointRadius: 0, tension: 0.4 },
                    { data: [], pointBackgroundColor: 'red', pointRadius: 6, showLine: false }
                ]
            },
            options: { ...commonOpts, scales: { ...commonOpts.scales, x: {title:{display:true, text:'Temp (°C)'}} } }
        });

        chartE = new Chart(document.getElementById('chartEnz'), {
            type: 'line',
            data: {
                labels: Array.from({length:16}, (_,i)=>i), 
                datasets: [
                    { data: [], borderColor: '#43a047', borderWidth: 2, pointRadius: 0, tension: 0.3 },
                    { data: [], pointBackgroundColor: 'red', pointRadius: 6, showLine: false }
                ]
            },
            options: { ...commonOpts, scales: { ...commonOpts.scales, x: {title:{display:true, text:'Enzym Koncentration'}} } }
        });

        let sLabels = []; 
        for(let i=0; i<=100; i+=2) sLabels.push(i);

        chartS = new Chart(document.getElementById('chartSub'), {
            type: 'line',
            data: {
                labels: sLabels,
                datasets: [
                    { data: [], borderColor: '#fb8c00', borderWidth: 2, pointRadius: 0, tension: 0.3 },
                    { data: [], pointBackgroundColor: 'red', pointRadius: 6, showLine: false }
                ]
            },
            options: { ...commonOpts, scales: { ...commonOpts.scales, x: {title:{display:true, text:'Substrat Koncentration'}} } }
        });
    }

    function updateCharts() {
        // Vi bruger 'calculateTheoreticalRate' til at tegne graferne.
        // Det sikrer at grafen "forudsiger" simulationen korrekt.
        // Y-aksen er skaleret til Max RPM (1800) for at matche speedometeret.

        // 1. TEMP GRAF
        let tData = [];
        for(let t=0; t<=70; t++) {
            tData.push(calculateTheoreticalRate(t, state.enzymeCount, state.substrateCount));
        }
        chartT.data.datasets[0].data = tData;
        
        let curTVal = calculateTheoreticalRate(state.temp, state.enzymeCount, state.substrateCount);
        let pT = new Array(71).fill(null); pT[state.temp] = curTVal;
        chartT.data.datasets[1].data = pT;
        // Opdater Y-akse dynamisk så toppen ikke klippes, men fastlåst hvis muligt
        chartT.options.scales.y.suggestedMax = 1000; 
        chartT.update();


        // 2. ENZYM GRAF (Mætning vises her!)
        // Vi varierer e fra 0 til 15, men holder t og s fast fra sliderne
        let eData = [];
        for(let e=0; e<=15; e++) {
            eData.push(calculateTheoreticalRate(state.temp, e, state.substrateCount));
        }
        chartE.data.datasets[0].data = eData;
        let eVal = calculateTheoreticalRate(state.temp, state.enzymeCount, state.substrateCount);
        chartE.data.datasets[1].data = [{x: state.enzymeCount, y: eVal}];
        chartE.update();


        // 3. SUBSTRAT GRAF
        // Vi varierer s fra 0 til 100
        let sData = [];
        for(let s=0; s<=100; s+=2) {
            sData.push(calculateTheoreticalRate(state.temp, state.enzymeCount, s));
        }
        chartS.data.datasets[0].data = sData;
        let sVal = calculateTheoreticalRate(state.temp, state.enzymeCount, state.substrateCount);
        chartS.data.datasets[1].data = [{x: state.substrateCount, y: sVal}];
        chartS.update();
    }

    // Handlers
    document.getElementById('slider-temp').addEventListener('input', (e) => {
        state.temp = parseInt(e.target.value);
        document.getElementById('val-temp').innerText = state.temp;
        updateStatus();
    });
    document.getElementById('slider-enz').addEventListener('input', (e) => {
        state.enzymeCount = parseInt(e.target.value);
        document.getElementById('val-enz').innerText = state.enzymeCount;
        let diff = state.enzymeCount - enzymes.length;
        if(diff > 0) for(let i=0; i<diff; i++) enzymes.push(new Enzyme());
        else enzymes.splice(0, -diff);
        updateStatus();
    });
    document.getElementById('slider-sub').addEventListener('input', (e) => {
        state.substrateCount = parseInt(e.target.value);
        document.getElementById('val-sub').innerText = state.substrateCount;
        replenishSubstrates();
        updateStatus();
    });

    // Start
    initCharts();
    initSim();
    updateStatus();
    updatePhysics();

</script>

</body>
</html>