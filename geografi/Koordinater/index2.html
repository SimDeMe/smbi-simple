<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jordklode Simulator - Justerbar</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #1a1a2e; color: white; }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ccc;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            min-width: 220px;
        }
        
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #0055aa; border-bottom: 2px solid #0055aa; padding-bottom: 5px; }
        .coord-box { margin-bottom: 8px; font-size: 1.1rem; display: flex; justify-content: space-between; align-items: baseline; }
        .label { font-weight: bold; color: #555; font-size: 0.9rem; }
        .value { color: #000; font-family: 'Courier New', monospace; font-size: 1.3rem; font-weight: 700; }
        
        .legend { margin-top: 15px; font-size: 0.8rem; color: #444; background: #f0f0f0; padding: 10px; border-radius: 5px; }
        .dot { height: 10px; width: 10px; display: inline-block; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #fff;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-size: 1.1rem;
            font-weight: 500;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-panel">
        <h1>Koordinater</h1>
        <div class="coord-box">
            <span class="label">Bredde (Lat)</span>
            <span class="value" id="lat-display">0.00°</span>
        </div>
        <div class="coord-box">
            <span class="label">Længde (Lon)</span>
            <span class="value" id="lon-display">0.00°</span>
        </div>
        
        <div class="legend">
            <div><span class="dot" style="background:red;"></span>Ækvator</div>
            <div><span class="dot" style="background:#00cc00;"></span>Nul-meridian (London)</div>
            <div><span class="dot" style="background:#00ffff;"></span>Gitter (30°)</div>
        </div>
    </div>

    <div id="instructions">Klik og træk for at rotere • Scroll for at zoome • Hold musen over for at måle</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        //  HER KAN DU JUSTERE KODEN SELV:
        // ==========================================

        // 1. ROTATION AF KORTET
        // Prøv at ændre tallet her, hvis London ikke rammer den grønne streg.
        // Gode bud: 0, 1.57, 3.14, 4.71 eller negative tal som -1.57
        const OFFSET_ROTATION = 0; // (Ca. -90 grader)

        // 2. RETNING PÅ LÆNGDEGRAD (Øst/Vest)
        // Hvis New York bliver Øst, så sæt denne til true (eller omvendt).
        const REVERSE_LON = false; 

        // ==========================================

        // 1. Opsætning
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 6, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 6;
        controls.maxDistance = 50;

        // 2. Jordkloden
        const radius = 5;
        const geometry = new THREE.SphereGeometry(radius, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        
        const earthTextureUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/2048px-Blue_Marble_2002.png';
        
        let earthMesh; // Gemmer referencen så vi kan bruge den senere

        textureLoader.load(earthTextureUrl, function (texture) {
             texture.colorSpace = THREE.SRGBColorSpace;
             const material = new THREE.MeshPhongMaterial({ 
                map: texture,
                shininess: 2,
                flatShading: false
            });
            
            earthMesh = new THREE.Mesh(geometry, material);
            
            // HER BRUGER VI DIN INDSTILLING FRA TOPPEN
            earthMesh.rotation.y = OFFSET_ROTATION; 
            
            scene.add(earthMesh);
            addGridLines();
            animate();
        });

        // 3. Lys
        const ambientLight = new THREE.AmbientLight(0xffffff, 2.5); 
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 3, 5);
        scene.add(dirLight);

        // 4. Gitter-linjer
        function addGridLines() {
            function createLineCircle(type, degree, color, width) {
                const lineGeom = new THREE.BufferGeometry();
                const points = [];
                const segments = 128;
                if (type === 'lat') {
                    const r = radius * Math.cos(degree * (Math.PI / 180));
                    const y = radius * Math.sin(degree * (Math.PI / 180));
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        points.push(new THREE.Vector3(r * Math.cos(angle), y, r * Math.sin(angle)));
                    }
                } else {
                    const rotation = degree * (Math.PI / 180);
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const x = radius * Math.sin(angle) * Math.cos(rotation);
                        const y = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle) * Math.sin(rotation);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
                lineGeom.setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({ color: color, linewidth: width });
                const line = new THREE.Line(lineGeom, lineMat);
                line.scale.set(1.002, 1.002, 1.002);
                scene.add(line);
            }
            createLineCircle('lat', 0, 0xff0000, 3); // Ækvator
            createLineCircle('lon', 0, 0x00cc00, 3); // Nul-meridian (Grøn)

            const gridColor = 0x00ffff;
            for(let lat = -60; lat <= 60; lat+=30) {
                if(lat !== 0) createLineCircle('lat', lat, gridColor, 1);
            }
            for(let lon = 0; lon < 180; lon+=30) {
                if(lon !== 0) {
                    createLineCircle('lon', lon, gridColor, 1);
                    createLineCircle('lon', lon + 180, gridColor, 1);
                }
            }
        }

        // 5. Markør
        const marker = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 16, 16), 
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        scene.add(marker);
        marker.visible = false;

        // 6. Raycasting & Matematik
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const latDisplay = document.getElementById('lat-display');
        const lonDisplay = document.getElementById('lon-display');

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children);
            const hit = intersects.find(i => i.object === earthMesh); // Vi leder kun efter jordkloden

            if (hit) {
                const point = hit.point;
                marker.position.copy(point);
                marker.visible = true;

                // Latitude
                const phi = Math.acos(point.y / radius);
                let lat = 90 - (phi * (180 / Math.PI));

                // Longitude (Her tager vi højde for dine indstillinger)
                const theta = Math.atan2(point.z, point.x);
                let lon = (theta * (180 / Math.PI));
                
                // Vi modregner den rotation du har sat i toppen
                const rotationInDegrees = OFFSET_ROTATION * (180 / Math.PI);
                lon = lon - rotationInDegrees;

                // Her vender vi retningen, hvis du har valgt det i toppen
                if (REVERSE_LON) {
                    lon = -lon;
                }
                
                // Normaliser til -180...180
                while (lon > 180) lon -= 360;
                while (lon < -180) lon += 360;

                latDisplay.innerText = Math.abs(lat).toFixed(2) + "° " + (lat >= 0 ? "N" : "S");
                lonDisplay.innerText = Math.abs(lon).toFixed(2) + "° " + (lon >= 0 ? "Ø" : "V");
            } else {
                marker.visible = false;
                latDisplay.innerText = "--";
                lonDisplay.innerText = "--";
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>